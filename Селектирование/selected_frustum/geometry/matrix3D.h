// Класс для работы с векторами

class Vector4
{
 public:
  double V[4];

  Vector4() {}

  Vector4(double x, double y, double z)
  {
    V[0] = x;
    V[1] = y;
    V[2] = z;
    V[3] = 1.0;
  }

  void normalize()
  {
    V[0] /= V[3];
    V[1] /= V[3];
    V[2] /= V[3];
    V[3] /= V[3];
  }
};

// Класс для работы с матрицами. Матрица хранится по столбцам (как в OpenGL)
class Matrix4
{
  public:

   double M[16];


   Matrix4 () {}


   Matrix4 (const double* m)
   {
     M[0] = m[0];  M[4] = m[4];  M[8] = m[8];    M[12] = m[12];
     M[1] = m[1];  M[5] = m[5];  M[9] = m[9];    M[13] = m[13];
     M[2] = m[2];  M[6] = m[6];  M[10] = m[10];  M[14] = m[14]; 
     M[3] = m[3];  M[7] = m[7];  M[11] = m[11];  M[15] = m[15];
   }



   Matrix4 operator * (Matrix4& A)
   {
     Matrix4 R;
     // Первый столбец результирующей матрицы
     R.M[0] =  M[0]*A.M[0]  +  M[4]*A.M[1]  +  M[8]*A.M[2]   +  M[12]*A.M[3];
     R.M[1] =  M[1]*A.M[0]  +  M[5]*A.M[1]  +  M[9]*A.M[2]   +  M[13]*A.M[3];
     R.M[2] =  M[2]*A.M[0]  +  M[6]*A.M[1]  +  M[10]*A.M[2]  +  M[14]*A.M[3];
     R.M[3] =  M[3]*A.M[0]  +  M[7]*A.M[1]  +  M[11]*A.M[2]  +  M[15]*A.M[3];
     
     // Второй столбец
     R.M[4] =  M[0]*A.M[4]  +  M[4]*A.M[5]  +  M[8]*A.M[6]   +  M[12]*A.M[7];
     R.M[5] =  M[1]*A.M[4]  +  M[5]*A.M[5]  +  M[9]*A.M[6]   +  M[13]*A.M[7];
     R.M[6] =  M[2]*A.M[4]  +  M[6]*A.M[5]  +  M[10]*A.M[6]  +  M[14]*A.M[7];
     R.M[7] =  M[3]*A.M[4]  +  M[7]*A.M[5]  +  M[11]*A.M[6]  +  M[15]*A.M[7];
     
     // Третий столбец
     R.M[8] =  M[0]*A.M[8]  +  M[4]*A.M[9]  +  M[8]*A.M[10]  +  M[12]*A.M[11];
     R.M[9] =  M[1]*A.M[8]  +  M[5]*A.M[9]  +  M[9]*A.M[10]  +  M[13]*A.M[11];
     R.M[10] = M[2]*A.M[8]  +  M[6]*A.M[9]  +  M[10]*A.M[10] +  M[14]*A.M[11];
     R.M[11] = M[3]*A.M[8]  +  M[7]*A.M[9]  +  M[11]*A.M[10] +  M[15]*A.M[11];
     
     // Четвёртый столбец
     R.M[12] = M[0]*A.M[12] +  M[4]*A.M[13] +  M[8]*A.M[14]  +  M[12]*A.M[15];
     R.M[13] = M[1]*A.M[12] +  M[5]*A.M[13] +  M[9]*A.M[14]  +  M[13]*A.M[15];
     R.M[14] = M[2]*A.M[12] +  M[6]*A.M[13] +  M[10]*A.M[14] +  M[14]*A.M[15];
     R.M[15] = M[3]*A.M[12] +  M[7]*A.M[13] +  M[11]*A.M[14] +  M[15]*A.M[15];
     return R;
   }



   Vector4 operator * (Vector4& A)
   {
     Vector4 R;
     R.V[0] = M[0]*A.V[0]  +  M[4]*A.V[1]  +  M[8]*A.V[2]   +  M[12]*A.V[3];
     R.V[1] = M[1]*A.V[0]  +  M[5]*A.V[1]  +  M[9]*A.V[2]   +  M[13]*A.V[3];
     R.V[2] = M[2]*A.V[0]  +  M[6]*A.V[1]  +  M[10]*A.V[2]  +  M[14]*A.V[3];
     R.V[3] = M[3]*A.V[0]  +  M[7]*A.V[1]  +  M[11]*A.V[2]  +  M[15]*A.V[3];
     return R;
   }



   // Функция возвращает обратную матрицу
   Matrix4 operator ~()
   {
     int i, j, k;

     double R[4][4] = { {1.0, 0.0, 0.0, 0.0},
                        {0.0, 1.0, 0.0, 0.0},
                        {0.0, 0.0, 1.0, 0.0},
                        {0.0, 0.0, 0.0, 1.0} };

     double A[4][4] = { {M[0],  M[1],  M[2],  M[3]},
                        {M[4],  M[5],  M[6],  M[7]},
                        {M[8],  M[9],  M[10], M[11]},
                        {M[12], M[13], M[14], M[15]} } ;

     double d, a;

     // Операция ротации матрицы методом Жордана-Гаусса
     for(i=0;i < 4;i++)
     {
       d = 1 / A[i][i];
       for (j=0; j < 4; j++)
       {
         A[i][j] *= d;
         R[i][j] *= d;
       }
       for(j=0;j < 4;j++)
       {
         if(i != j)
         {
           a = -A[j][i];
           if(a != 0)
           {
               for (k=0; k < 4;k++)
               {
                 A[j][k] += A[i][k] * a;
                 R[j][k] += R[i][k] * a;
               }
           }
         }
       }
     }
     return Matrix4((double*)R);
   }

};
